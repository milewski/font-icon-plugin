import * as webpack from 'webpack'
import { Communicator } from './communicator'
import { Compiler } from './Interfaces/Compiler'
import LoaderContext = webpack.loader.LoaderContext

export const PLUGIN_NAME = 'icon-font-webpack'

export class FontIconPlugin {

    constructor(private options) {}

    public apply(compiler: Compiler): void {

        const options: any = {
            publicPath: '/',
            fallbackType: 'eot',
            filename: 'font-icon.[ext]'
        }

        const communicator = new Communicator({ ...options, ...this.options })

        /**
         * Inject plugin into loader
         */
        compiler.options.module.rules.forEach(rule => {

            if (rule.test.test('.scss')) {

                const loader = rule.use.find(ruller => ruller.loader === 'postcss-loader')

                if (loader) {

                    loader.options.plugins = [
                        communicator.gatherStatistics(),
                        communicator.generateFonts()
                    ]

                }

            }

        })

        compiler.plugin('emit', (compilation, callback) => {

            communicator.assets.forEach(asset => {
                compilation.assets[ asset.name ] = asset.content
            })

            console.log(communicator.assets)

            callback()

        })
        //
        //     compilation.chunks.forEach(function(chunk) {
        //         // Explore each module within the chunk (built inputs):
        //         chunk.forEachModule(function(module) {
        //             // Explore each source file path that was included into the module:
        //             module.fileDependencies.forEach(function(filepath) {
        //                 // we've learned a lot about the source structure now...
        //                 console.log(filepath)
        //             });
        //         });
        //
        //         // Explore each asset filename generated by the chunk:
        //         chunk.files.forEach(function(filename) {
        //             // Get the asset source for each file generated by the chunk:
        //             var source = compilation.assets[filename].source();
        //             console.log(source)
        //         });
        //     });
        //
        //     callback();
        //
        // })
        // var assets = compilation.assets

        //     return Promise.all(Object.keys(assets).reduce(function (result, name) {
        //
        //         if (!/\.css$/.test(name)) {
        //             return result;
        //         }
        //
        //         // var asset = assets[ name ]
        //         // var originalCss = asset.source()
        //
        //         console.log('vai')
        //
        //         return result
        //     }, [])).then(function () {
        //         compileCallback()
        //     }).catch(compileCallback)
        // })

        // compiler.plugin('emit', (compilation, callback) => {
        //
        //     console.log('\n Trying', communicator.compilation)
        //
        //     communicator.getAssets().then(assets => {
        //         assets.forEach(({ name, content }) => compilation.assets[ name ] = content)
        //     }).then(() => callback())
        //
        // })

        // compiler.plugin('emit', (compilation, callback) => {
        //
        //     // console.log(compilation.assets)
        //     callback()
        //     // const wait = function () {
        //     //     setTimeout(() => {
        //     //         console.log(communicator.compilation)
        //     //         if (Object.keys(communicator.compilation.assets).length) {
        //     //
        //     //             callback()
        //     //         } else {
        //     //             wait()
        //     //         }
        //     //
        //     //     }, 1000)
        //     // }
        //     // wait()
        //
        //
        //     // try {
        //     //     if (path.parse(compilation.name).ext !== '.scss') {
        //     //         console.log('VAIVAI')
        //     //         return
        //     //     }
        //     // } catch {
        //     //
        //     // }
        //
        //     // if (compilation.name !== undefined) {
        //     //     return
        //     // }
        //     //
        //     // compilation.plugin('normal-module-loader', (context: loader.LoaderContext, { loaders }) => {
        //     //
        //     //
        //     //
        //     //     // loaders.forEach(entry => {
        //     //     //
        //     //     //     if (communicator.running) {
        //     //     //         return
        //     //     //     }
        //     //     //
        //     //     //     /**
        //     //     //      * Apply PostcssPlugin to every loader that includes the postcss-loader
        //     //     //      */
        //     //     //     if (entry.loader.match(/postcss-loader/) && this.containPlugins(entry, context)) {
        //     //     //         entry.options.plugins.push(
        //     //     //             communicator.gatherStatistics(),
        //     //     //             communicator.generateFonts()
        //     //     //             // new PostcssPlugin(communicator).initialize(),
        //     //     //             // new GeneratorPlugin(communicator).initialize()
        //     //     //         )
        //     //     //     }
        //     //     //
        //     //     // })
        //     //
        //     // })
        //
        // })

    }

    private containPlugins(entry: { options: { plugins: any[] } }, loader: LoaderContext): boolean {

        /**
         * If for some reason it happens to be a string, ignore it
         */
        if (typeof entry.options === 'string') {
            return false
        }

        if (typeof entry.options === 'undefined') {
            entry.options = { plugins: [] }
        }

        if (Array.isArray(entry.options.plugins)) {
            return !entry.options.plugins.some(plugin => plugin.postcssPlugin === PLUGIN_NAME)
        }

        if (typeof entry.options.plugins === 'function') {
            entry.options.plugins = [ ...entry.options.plugins(loader) ]
        } else {
            entry.options.plugins = []
        }

        return true

    }

}
